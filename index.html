<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa de Unidades Geomorfol√≥gicas</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c5530 0%, #1a3d1f 50%, #0f2412 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 380px;
            background: linear-gradient(180deg, #f8fffe 0%, #e8f5f0 100%);
            box-shadow: 3px 0 15px rgba(0,0,0,0.15);
            z-index: 1000;
            overflow-y: auto;
            border-right: 3px solid #2d5016;
        }
        
        .header {
            background: linear-gradient(135deg, #2d5016 0%, #4a7c59 50%, #2d5016 100%);
            color: white;
            padding: 25px 20px;
            text-align: center;
            position: relative;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M20 20c0 4.4-3.6 8-8 8s-8-3.6-8-8 3.6-8 8-8 8 3.6 8 8zm0-20c0 4.4-3.6 8-8 8s-8-3.6-8-8 3.6-8 8-8 8 3.6 8 8z'/%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.1;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 0.95em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .dept-info {
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 15px;
            margin-top: 10px;
            font-size: 0.8em;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .legend {
            padding: 20px;
            background: rgba(255,255,255,0.95);
            margin: 10px;
            border-radius: 10px;
            border: 2px solid #e8f5f0;
        }
        
        .legend h3 {
            margin: 0 0 15px 0;
            color: #2d5016;
            font-size: 1.1em;
            border-bottom: 2px solid #4a7c59;
            padding-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .legend h3::before {
            content: 'üó∫Ô∏è';
            margin-right: 8px;
        }
        
        .layer-control {
            background: rgba(255,255,255,0.95);
            margin: 10px;
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #e8f5f0;
        }
        
        .layer-control h3 {
            margin: 0 0 15px 0;
            color: #2d5016;
            font-size: 1.0em;
            border-bottom: 2px solid #4a7c59;
            padding-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .layer-control h3::before {
            content: 'üìã';
            margin-right: 8px;
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        
        .layer-toggle:hover {
            background-color: rgba(74, 124, 89, 0.1);
        }
        
        .layer-toggle input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #2d5016;
        }
        
        .layer-toggle label {
            flex: 1;
            color: #2d5016;
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .legend-item:hover {
            background-color: rgba(74, 124, 89, 0.1);
        }
        
        .legend-color {
            width: 22px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #2d5016;
            flex-shrink: 0;
        }
        
        .legend-text {
            flex: 1;
        }
        
        .legend-label {
            font-weight: 600;
            color: #2d5016;
            font-size: 0.82em;
            line-height: 1.1;
        }
        
        .legend-percent {
            color: #4a7c59;
            font-size: 0.75em;
            margin-top: 1px;
        }
        
        .controls {
            padding: 20px;
            background: rgba(255,255,255,0.95);
            margin: 10px;
            border-radius: 10px;
            border: 2px solid #e8f5f0;
        }
        
        .transparency-control {
            margin-bottom: 15px;
        }
        
        .transparency-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d5016;
            font-size: 0.9em;
        }
        
        .transparency-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #e8f5f0, #2d5016);
            outline: none;
            -webkit-appearance: none;
        }
        
        .transparency-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2d5016;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .transparency-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2d5016;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .btn {
            background: linear-gradient(135deg, #2d5016 0%, #4a7c59 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #1a3d1f 0%, #2d5016 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .info-box {
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 2px solid #4a7c59;
            color: #2d5016;
            font-size: 0.85em;
        }
        
        .credits {
            position: absolute;
            bottom: 5px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7em;
            color: #2d5016;
            border: 1px solid rgba(45, 80, 22, 0.3);
            z-index: 1000;
        }
        
        .btn {
            background: #4a5568;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background: #2d3748;
        }
        
        .file-input {
            margin-bottom: 15px;
        }
        
        .file-input input {
            width: 100%;
            padding: 8px;
            border: 2px dashed #cbd5e0;
            border-radius: 4px;
            background: #f7fafc;
        }
        
        #map {
            flex: 1;
            height: 100vh;
        }
        
        .info-box {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            border-left: 4px solid #4a5568;
            font-size: 0.85em;
        }
        
        .leaflet-popup-content {
            font-family: Arial, sans-serif;
        }
        
        .popup-title {
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 8px;
        }
        
        .popup-info {
            color: #4a5568;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>Unidades Geomorfol√≥gicas</h1>
                <p>Bacia do Rio Pindar√© - Maranh√£o</p>
                <div class="dept-info">
                    üåø Departamento de Estudos Ambientais
                </div>
            </div>
            
            <div class="layer-control">
                <h3>Controle de Camadas</h3>
                <div class="layer-toggle">
                    <input type="checkbox" id="toggle-geomorf" checked onchange="toggleGeomorfologia(this.checked)">
                    <label for="toggle-geomorf">Unidades Geomorfol√≥gicas</label>
                </div>
                <div class="layer-toggle">
                    <input type="checkbox" id="toggle-municipios" onchange="toggleMunicipios(this.checked)">
                    <label for="toggle-municipios">Limites Municipais do Estado do Maranh√£o</label>
                </div>
            </div>
            
            <div class="legend">
                <h3>Legenda</h3>
                <div id="legend-items">
                    <!-- Legenda ser√° preenchida dinamicamente -->
                </div>
            </div>
            
            <div class="controls">
                <div class="transparency-control">
                    <label for="transparency-slider">Transpar√™ncia das unidades:</label>
                    <input type="range" id="transparency-slider" class="transparency-slider" 
                           min="0" max="100" value="70" 
                           oninput="ajustarTransparencia(this.value)">
                    <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: #4a7c59; margin-top: 3px;">
                        <span>Transparente</span>
                        <span>Opaco</span>
                    </div>
                </div>
                
                <button class="btn" onclick="ajustarVista()">üó∫Ô∏è Ajustar Vista</button>
                <button class="btn" onclick="alternarCamada()">üé® Alterar Mapa</button>
                <button class="btn" onclick="exportarDados()">üíæ Exportar</button>
                
                <div class="info-box" id="status-info">
                    <strong>üîÑ Conectando ao GitHub...</strong><br>
                    Carregando dados ambientais...
                </div>
            </div>
        </div>
        
        <div id="map"></div>
        <div class="credits">Desenvolvido por Pereira R.B, 2025</div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Proj4js para transforma√ß√£o de coordenadas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4/2.9.0/proj4.min.js"></script>
    
    <script>
        // Aguardar carregamento do proj4 antes de executar
        document.addEventListener('DOMContentLoaded', function() {
            // Verificar se proj4 carregou
            if (typeof proj4 === 'undefined') {
                console.error('Proj4js n√£o carregou. Tentando fallback...');
                document.getElementById('status-info').innerHTML = `
                    <strong>‚ö†Ô∏è Biblioteca de proje√ß√£o n√£o carregou</strong><br>
                    Tentando carregar dados sem transforma√ß√£o...
                `;
                // Continuar sem transforma√ß√£o
                inicializarMapa(false);
            } else {
                console.log('‚úÖ Proj4js carregado com sucesso');
                inicializarMapa(true);
            }
        });
        
        function inicializarMapa(comTransformacao) {
        // Configura√ß√£o do mapa
        let map = L.map('map').setView([-3.5, -45.0], 8);
        
        // Camadas de mapa
        let mapLayers = {
            openStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap'
            })
        };
        
        let currentLayer = 'openStreetMap';
        mapLayers[currentLayer].addTo(map);
        
        // Vari√°veis globais
        let geojsonLayer = null;
        let municipiosLayer = null;
        let unidadesData = [];
        
        // Cores para as unidades geomorfol√≥gicas
        const coresUnidades = {
            'R1d - Plan√≠cies fluviomarinhas': '#87CEEB',
            'R3a2 - Superf√≠cies aplainadas degradadas': '#DAA520', 
            'R4a1 - Dom√≠nio de colinas amplas e suaves': '#F08080',
            'R2b3 - Planaltos': '#8B4513',
            'R4b - Dom√≠nio de morros e serras baixas': '#A0522D',
            'R2b2 - Baixos plat√¥s dissecados': '#F5DEB3',
            'R4f - Vales encaixados': '#2E8B57',
            'R2b1 - Baixos plat√¥s': '#FF8C00',
            'R4e - Degraus estruturais e rebordos erosivos': '#FF6347',
            'R4a2 - Dom√≠nio de colinas dissecadas e de morros baixos': '#DDA0DD',
            'R1a - Plan√≠cies fluviais ou fl√∫vio-lacustres': '#90EE90'
        };
        
        // Percentuais das unidades (baseado na imagem)
        const percentuaisUnidades = {
            'R1d - Plan√≠cies fluviomarinhas': '1,65%',
            'R3a2 - Superf√≠cies aplainadas degradadas': '18,68%',
            'R4a1 - Dom√≠nio de colinas amplas e suaves': '7,67%',
            'R2b3 - Planaltos': '11,09%',
            'R4b - Dom√≠nio de morros e serras baixas': '10,33%',
            'R2b2 - Baixos plat√¥s dissecados': '20,10%',
            'R4f - Vales encaixados': '11,74%',
            'R2b1 - Baixos plat√¥s': '3,42%',
            'R4e - Degraus estruturais e rebordos erosivos': '1%',
            'R4a2 - Dom√≠nio de colinas dissecadas e de morros baixos': '10,79%',
            'R1a - Plan√≠cies fluviais ou fl√∫vio-lacustres': '2,18%'
        };
        
        // Fun√ß√£o para obter cor da unidade
        function obterCor(nomeUnidade) {
            return coresUnidades[nomeUnidade] || '#808080';
        }
        
        // Fun√ß√£o para estilizar as features baseado nos dados reais - CORRIGIDA
        function estilizarFeature(feature) {
            const props = feature.properties;
            
            // Tentar identificar a unidade geomorfol√≥gica pelos dados reais
            let nomeUnidade = 'Unidade n√£o identificada';
            
            // Mapear baseado no campo RELEVO - vers√£o mais precisa e espec√≠fica
            if (props.RELEVO) {
                const relevo = props.RELEVO.toLowerCase();
                
                // Mapeamento corrigido e mais espec√≠fico
                if (relevo.includes('superf√≠cies aplainadas retocadas') || relevo.includes('superf√≠cies aplainadas degradadas')) {
                    nomeUnidade = 'R3a2 - Superf√≠cies aplainadas degradadas';
                } else if (relevo.includes('plan√≠cies fl√∫vio-marinhas') || relevo.includes('plan√≠cies fluviomarinhas')) {
                    nomeUnidade = 'R1d - Plan√≠cies fluviomarinhas';
                } else if (relevo.includes('dom√≠nios de colinas amplas e suaves') || relevo.includes('dom√≠nio de colinas amplas e suaves')) {
                    nomeUnidade = 'R4a1 - Dom√≠nio de colinas amplas e suaves';
                } else if (relevo.includes('dom√≠nios de colinas') && !relevo.includes('amplas') && !relevo.includes('dissecadas')) {
                    nomeUnidade = 'R4a1 - Dom√≠nio de colinas amplas e suaves'; // Assumindo que "Dom√≠nios de colinas" gen√©rico √© este
                } else if (relevo.includes('planaltos') && !relevo.includes('baixos')) {  
                    nomeUnidade = 'R2b3 - Planaltos';
                } else if (relevo.includes('dom√≠nio de morros e de serras baixas') || relevo.includes('dom√≠nio de morros e serras baixas')) {
                    nomeUnidade = 'R4b - Dom√≠nio de morros e serras baixas';
                } else if (relevo.includes('baixos plat√¥s dissecados')) {
                    nomeUnidade = 'R2b2 - Baixos plat√¥s dissecados';
                } else if (relevo.includes('vales encaixados')) {
                    nomeUnidade = 'R4f - Vales encaixados';
                } else if (relevo.includes('baixos plat√¥s') && !relevo.includes('dissecados')) {
                    nomeUnidade = 'R2b1 - Baixos plat√¥s';
                } else if (relevo.includes('degraus estruturais') || relevo.includes('rebordos erosivos')) {
                    nomeUnidade = 'R4e - Degraus estruturais e rebordos erosivos';
                } else if (relevo.includes('dom√≠nio de colinas dissecadas') || relevo.includes('morros baixos')) {
                    nomeUnidade = 'R4a2 - Dom√≠nio de colinas dissecadas e de morros baixos';
                } else if (relevo.includes('plan√≠cies fluviais') || relevo.includes('fl√∫vio-lacustres')) {
                    nomeUnidade = 'R1a - Plan√≠cies fluviais ou fl√∫vio-lacustres';
                }
            }
            
            // Se n√£o conseguiu identificar, usar o campo RELEVO diretamente
            if (nomeUnidade === 'Unidade n√£o identificada' && props.RELEVO) {
                nomeUnidade = props.RELEVO;
            }
            
            return {
                fillColor: obterCor(nomeUnidade),
                weight: 0, // Remove bordas
                opacity: 0,
                color: 'transparent',
                fillOpacity: 0.7
            };
        }
        
        // Fun√ß√£o para criar popup com informa√ß√µes detalhadas e limpas
        function criarPopup(feature, layer) {
            const props = feature.properties;
            
            // Identificar unidade geomorfol√≥gica
            let unidadeGeomorf = props.RELEVO || 'N√£o identificada';
            
            let popupContent = `
                <div class="popup-title">${unidadeGeomorf}</div>
                <div class="popup-info">
                    <strong>Tipo:</strong> Unidade Geomorfol√≥gica<br>
            `;
            
            // Adicionar informa√ß√µes espec√≠ficas formatadas
            if (props.DECLIVIDAD) {
                popupContent += `<strong>Declividade:</strong> ${props.DECLIVIDAD}<br>`;
            }
            
            if (props.AMP_TOPO) {
                popupContent += `<strong>Amplitude do topo:</strong> ${props.AMP_TOPO}<br>`;
            }
            
            if (props.RELEVO) {
                popupContent += `<strong>Unidades Geomorfol√≥gicas:</strong> ${props.RELEVO}<br>`;
            }
            
            if (props.√Årea || props.AREA || props.Area) {
                const area = props.√Årea || props.AREA || props.Area;
                popupContent += `<strong>√Årea da Fei√ß√£o Geomorfol√≥gica:</strong> ${area}<br>`;
            }
            
            if (props.Area_Bacia) {
                popupContent += `<strong>√Årea Bacia Hidrogr√°fica:</strong> ${props.Area_Bacia}<br>`;
            }
            
            if (props.F_pbacia) {
                popupContent += `<strong>Mun. que possuem esta fei√ß√£o geomorfol√≥gica:</strong> ${props.F_pbacia}<br>`;
                
                // Adicionar Muni_pArea logo abaixo sem r√≥tulo
                if (props.Muni_pArea) {
                    popupContent += `${props.Muni_pArea}<br>`;
                }
            }
            
            // Adicionar outras propriedades, excluindo as que n√£o queremos mostrar
            const camposExcluir = [
                'RELEVO', 'DECLIVIDAD', 'AMP_TOPO', '√Årea', 'AREA', 'Area', 
                'Area_Bacia', 'F_pbacia', 'Muni_pArea',
                'OBJECTID', 'Shape_Leng', 'Shape_Area' // Excluir campos t√©cnicos
            ];
            
            Object.keys(props).forEach(key => {
                if (!camposExcluir.includes(key)) {
                    if (props[key] !== null && props[key] !== undefined && props[key] !== '') {
                        popupContent += `<strong>${key}:</strong> ${props[key]}<br>`;
                    }
                }
            });
            
            popupContent += '</div>';
            
            layer.bindPopup(popupContent);
        }
        
        // Fun√ß√£o para criar a legenda
        function criarLegenda() {
            const legendContainer = document.getElementById('legend-items');
            legendContainer.innerHTML = '';
            
            Object.entries(coresUnidades).forEach(([unidade, cor]) => {
                const percentual = percentuaisUnidades[unidade] || '0%';
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${cor}"></div>
                    <div class="legend-text">
                        <div class="legend-label">${unidade}</div>
                        <div class="legend-percent">${percentual}</div>
                    </div>
                `;
                
                legendContainer.appendChild(legendItem);
            });
        }
        
        // Fun√ß√£o para carregar GeoJSON
        function carregarGeoJSON(geojsonData) {
            try {
                // Remover camada anterior se existir
                if (geojsonLayer) {
                    map.removeLayer(geojsonLayer);
                }
                
                // Criar nova camada GeoJSON
                geojsonLayer = L.geoJSON(geojsonData, {
                    style: estilizarFeature,
                    onEachFeature: criarPopup
                }).addTo(map);
                
                // Ajustar vista para mostrar todos os dados
                map.fitBounds(geojsonLayer.getBounds());
                
                console.log('GeoJSON carregado com sucesso!');
                
            } catch (error) {
                console.error('Erro ao carregar GeoJSON:', error);
                alert('Erro ao carregar o arquivo GeoJSON. Verifique o formato do arquivo.');
            }
        }
        
        // Lista de URLs poss√≠veis para tentar - incluindo munic√≠pios
        const urlsGeomorfologia = [
            'https://raw.githubusercontent.com/brunnosilllva/Dinamica/main/Geomorf_Pindar√©.geojson',
            'https://raw.githubusercontent.com/brunnosilllva/Dinamica/master/Geomorf_Pindar√©.geojson'
        ];
        
        const urlsMunicipios = [
            'https://raw.githubusercontent.com/brunnosilllva/Dinamica/main/Limites%20Municipais%20do%20Estado%20do%20Maranh√£o.json',
            'https://raw.githubusercontent.com/brunnosilllva/Dinamica/master/Limites%20Municipais%20do%20Estado%20do%20Maranh√£o.json'
        ];

        // Carregar automaticamente do GitHub com m√∫ltiplas tentativas
        async function carregarArquivoAutomatico() {
            const statusInfo = document.getElementById('status-info');
            
            statusInfo.innerHTML = '<strong>üîÑ Carregando dados ambientais...</strong><br>Processando unidades geomorfol√≥gicas...';
            
            // Carregar geomorfologia
            await carregarDados(urlsGeomorfologia, 'geomorfologia');
        }
        
        // Fun√ß√£o gen√©rica para carregar dados
        async function carregarDados(urls, tipo) {
            const statusInfo = document.getElementById('status-info');
            
            for (let i = 0; i < urls.length; i++) {
                try {
                    const url = urls[i];
                    console.log(`Tentando carregar ${tipo} - Tentativa ${i + 1}: ${url}`);
                    
                    const response = await fetch(url);
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (tipo === 'geomorfologia') {
                            // Verificar se √© um GeoJSON v√°lido
                            if (!data.type || data.type !== 'FeatureCollection') {
                                throw new Error('Formato GeoJSON inv√°lido');
                            }
                            
                            const dadosProcessados = verificarETransformarProjecao(data);
                            carregarGeoJSON(dadosProcessados);
                            
                            statusInfo.innerHTML = `
                                <strong>Proje√ß√£o:</strong> WGS84 (padr√£o)<br>
                                ‚Ä¢ Clique nas √°reas para detalhes
                            `;
                        } else if (tipo === 'municipios') {
                            carregarMunicipios(data);
                        }
                        
                        return; // Sucesso, parar tentativas
                    }
                    
                } catch (error) {
                    console.log(`Tentativa ${i + 1} para ${tipo} falhou:`, error.message);
                    continue; // Tentar pr√≥xima URL
                }
            }
            
            // Se chegou aqui, todas as tentativas falharam
            if (tipo === 'geomorfologia') {
                statusInfo.innerHTML = `
                    <strong>‚ùå N√£o foi poss√≠vel carregar dados</strong><br>
                    Verifique a conex√£o com GitHub
                `;
            }
        }
        
        // Fun√ß√£o para carregar munic√≠pios
        function carregarMunicipios(geojsonData) {
            try {
                if (municipiosLayer) {
                    map.removeLayer(municipiosLayer);
                }
                
                municipiosLayer = L.geoJSON(geojsonData, {
                    style: {
                        fillColor: 'transparent',
                        weight: 2,
                        opacity: 0.8,
                        color: '#000000',
                        fillOpacity: 0
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const nomeMunicipio = props.name || props.NAME || props.nome || props.NOME || 'Munic√≠pio n√£o identificado';
                        
                        layer.bindPopup(`
                            <div class="popup-title">${nomeMunicipio}</div>
                            <div class="popup-info">
                                <strong>Tipo:</strong> Limite Municipal<br>
                                <strong>Estado:</strong> Maranh√£o
                            </div>
                        `);
                    }
                });
                
                console.log('Munic√≠pios carregados com sucesso!');
                
            } catch (error) {
                console.error('Erro ao carregar munic√≠pios:', error);
            }
        }
        
        // Fun√ß√µes de controle de camadas
        window.toggleGeomorfologia = function(mostrar) {
            if (geojsonLayer) {
                if (mostrar) {
                    if (!map.hasLayer(geojsonLayer)) {
                        map.addLayer(geojsonLayer);
                    }
                } else {
                    if (map.hasLayer(geojsonLayer)) {
                        map.removeLayer(geojsonLayer);
                    }
                }
            }
        };
        
        window.toggleMunicipios = async function(mostrar) {
            if (mostrar) {
                if (!municipiosLayer) {
                    // Carregar munic√≠pios se ainda n√£o foi carregado
                    await carregarDados(urlsMunicipios, 'municipios');
                }
                if (municipiosLayer && !map.hasLayer(municipiosLayer)) {
                    map.addLayer(municipiosLayer);
                }
            } else {
                if (municipiosLayer && map.hasLayer(municipiosLayer)) {
                    map.removeLayer(municipiosLayer);
                }
            }
        };
        
        // Definir proje√ß√µes (s√≥ se proj4 estiver dispon√≠vel)
        let transformacaoDisponivel = false;
        
        if (typeof proj4 !== 'undefined') {
            proj4.defs([
                ['EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs'],
                ['EPSG:31983', '+proj=utm +zone=23 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs']
            ]);
            transformacaoDisponivel = true;
        }

        // Fun√ß√£o para verificar e transformar proje√ß√£o se necess√°rio
        function verificarETransformarProjecao(geojsonData) {
            const temCRS = geojsonData.crs && geojsonData.crs.properties;
            let dadosTransformados = { ...geojsonData };
            
            if (temCRS) {
                const crsName = geojsonData.crs.properties.name;
                console.log('CRS detectado:', crsName);
                
                // Verificar se √© EPSG:31983 (SIRGAS 2000 UTM 23S)
                if (crsName.includes('31983')) {
                    if (transformacaoDisponivel) {
                        console.log('üîÑ Transformando de EPSG:31983 para WGS84...');
                        
                        dadosTransformados = transformarCoordenadas(geojsonData, 'EPSG:31983', 'EPSG:4326');
                        
                        // Remover CRS do resultado para usar WGS84 padr√£o
                        delete dadosTransformados.crs;
                        
                        console.log('‚úÖ Transforma√ß√£o conclu√≠da!');
                    } else {
                        console.warn('‚ö†Ô∏è Proj4js n√£o dispon√≠vel. Coordenadas podem estar incorretas.');
                        
                        // Tentar convers√£o manual simples (aproximada)
                        dadosTransformados = tentarConversaoManual(geojsonData);
                    }
                }
            }
            
            // Verificar coordenadas ap√≥s transforma√ß√£o
            if (dadosTransformados.features && dadosTransformados.features.length > 0) {
                const primeiraFeature = dadosTransformados.features[0];
                if (primeiraFeature.geometry && primeiraFeature.geometry.coordinates) {
                    const coords = extrairPrimeiraCoordenada(primeiraFeature.geometry);
                    
                    if (coords) {
                        const [lng, lat] = coords;
                        console.log('Coordenadas finais:', lat, lng);
                        
                        // Verificar se est√° na regi√£o esperada (Maranh√£o/Pindar√©)
                        const dentroRegiao = (lat >= -6 && lat <= -1) && (lng >= -48 && lng <= -42);
                        
                        if (dentroRegiao) {
                            console.log('‚úÖ Coordenadas est√£o na regi√£o correta do Maranh√£o');
                            // Centralizar mapa na regi√£o
                            map.setView([lat, lng], 9);
                        } else {
                            console.warn('‚ö†Ô∏è Coordenadas ainda fora da regi√£o esperada');
                            // Se parece UTM, tentar centralizar na regi√£o do Maranh√£o mesmo assim
                            if (Math.abs(lat) > 100) { // Parece ser UTM ainda
                                map.setView([-3.5, -45.0], 8); // Centro aproximado do Maranh√£o
                            } else {
                                map.setView([lat, lng], 8);
                            }
                        }
                    }
                }
            }
            
            return dadosTransformados;
        }
        
        // Fun√ß√£o para transformar coordenadas de um GeoJSON (s√≥ se proj4 dispon√≠vel)
        function transformarCoordenadas(geojson, origemCRS, destinoCRS) {
            if (!transformacaoDisponivel) return geojson;
            
            const geojsonTransformado = JSON.parse(JSON.stringify(geojson)); // Deep copy
            
            function transformarGeometry(geometry) {
                switch (geometry.type) {
                    case 'Point':
                        geometry.coordinates = proj4(origemCRS, destinoCRS, geometry.coordinates);
                        break;
                    
                    case 'LineString':
                        geometry.coordinates = geometry.coordinates.map(coord => 
                            proj4(origemCRS, destinoCRS, coord)
                        );
                        break;
                    
                    case 'Polygon':
                        geometry.coordinates = geometry.coordinates.map(ring =>
                            ring.map(coord => proj4(origemCRS, destinoCRS, coord))
                        );
                        break;
                    
                    case 'MultiPoint':
                        geometry.coordinates = geometry.coordinates.map(coord =>
                            proj4(origemCRS, destinoCRS, coord)
                        );
                        break;
                    
                    case 'MultiLineString':
                        geometry.coordinates = geometry.coordinates.map(line =>
                            line.map(coord => proj4(origemCRS, destinoCRS, coord))
                        );
                        break;
                    
                    case 'MultiPolygon':
                        geometry.coordinates = geometry.coordinates.map(polygon =>
                            polygon.map(ring =>
                                ring.map(coord => proj4(origemCRS, destinoCRS, coord))
                            )
                        );
                        break;
                    
                    case 'GeometryCollection':
                        geometry.geometries.forEach(transformarGeometry);
                        break;
                }
            }
            
            // Transformar todas as features
            if (geojsonTransformado.features) {
                geojsonTransformado.features.forEach(feature => {
                    if (feature.geometry) {
                        transformarGeometry(feature.geometry);
                    }
                });
            }
            
            return geojsonTransformado;
        }
        
        // Fun√ß√£o fallback para convers√£o manual aproximada (UTM 23S para WGS84)
        function tentarConversaoManual(geojsonData) {
            console.log('‚ö†Ô∏è Usando convers√£o manual aproximada...');
            
            // Esta √© uma convers√£o muito aproximada para UTM Zone 23S
            // N√£o √© precisa, mas pode dar uma ideia da localiza√ß√£o
            const geojsonConvertido = JSON.parse(JSON.stringify(geojsonData));
            
            function converterCoordenada([x, y]) {
                // Convers√£o aproximada de UTM 23S para lat/lng
                // Centro da zona UTM 23S: longitude -45¬∞
                const lng = -45 + (x - 500000) / 111320;
                const lat = (y - 10000000) / 111320;
                
                return [lng, lat];
            }
            
            function converterGeometry(geometry) {
                switch (geometry.type) {
                    case 'Point':
                        geometry.coordinates = converterCoordenada(geometry.coordinates);
                        break;
                    
                    case 'LineString':
                        geometry.coordinates = geometry.coordinates.map(converterCoordenada);
                        break;
                    
                    case 'Polygon':
                        geometry.coordinates = geometry.coordinates.map(ring =>
                            ring.map(converterCoordenada)
                        );
                        break;
                    
                    case 'MultiPolygon':
                        geometry.coordinates = geometry.coordinates.map(polygon =>
                            polygon.map(ring =>
                                ring.map(converterCoordenada)
                            )
                        );
                        break;
                }
            }
            
            if (geojsonConvertido.features) {
                geojsonConvertido.features.forEach(feature => {
                    if (feature.geometry) {
                        converterGeometry(feature.geometry);
                    }
                });
            }
            
            delete geojsonConvertido.crs;
            return geojsonConvertido;
        }
        
        // Fun√ß√£o auxiliar para extrair primeira coordenada
        function extrairPrimeiraCoordenada(geometry) {
            switch (geometry.type) {
                case 'Point':
                    return geometry.coordinates;
                case 'Polygon':
                    return geometry.coordinates[0][0];
                case 'MultiPolygon':
                    return geometry.coordinates[0][0][0];
                case 'LineString':
                    return geometry.coordinates[0];
                case 'MultiLineString':
                    return geometry.coordinates[0][0];
                default:
                    return null;
            }
        }
        
        // Fun√ß√£o para ajustar transpar√™ncia das unidades
        window.ajustarTransparencia = function(valor) {
            const transparencia = valor / 100;
            
            if (geojsonLayer) {
                geojsonLayer.eachLayer(function(layer) {
                    layer.setStyle({
                        fillOpacity: transparencia
                    });
                });
            }
        };
        
        // Fun√ß√µes dos bot√µes (agora dentro da fun√ß√£o inicializarMapa)
        window.ajustarVista = function() {
            if (geojsonLayer) {
                map.fitBounds(geojsonLayer.getBounds());
            }
        };
        
        window.alternarCamada = function() {
            map.removeLayer(mapLayers[currentLayer]);
            
            if (currentLayer === 'openStreetMap') {
                currentLayer = 'satellite';
            } else if (currentLayer === 'satellite') {
                currentLayer = 'terrain';
            } else {
                currentLayer = 'openStreetMap';
            }
            
            mapLayers[currentLayer].addTo(map);
        };
        
        window.exportarDados = function() {
            if (geojsonLayer) {
                const dataStr = JSON.stringify(geojsonLayer.toGeoJSON(), null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'unidades_geomorfologicas_exportado.geojson';
                link.click();
                
                URL.revokeObjectURL(url);
            } else {
                alert('Nenhum dado carregado para exportar.');
            }
        };
        
        // Inicializar mapa e carregar dados automaticamente
        criarLegenda();
        carregarArquivoAutomatico();
        
        // Adicionar controles do mapa
        L.control.scale({
            imperial: false,
            metric: true,
            position: 'bottomright'
        }).addTo(map);
        
        // Adicionar indicador de norte
        const northControl = L.control({position: 'topright'});
        northControl.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'north-arrow');
            div.innerHTML = `
                <div style="
                    background: white;
                    border: 2px solid #333;
                    border-radius: 50%;
                    width: 50px;
                    height: 50px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 18px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                    cursor: help;
                " title="Norte Geogr√°fico">
                    ‚Üë<br><small style="font-size: 10px;">N</small>
                </div>
            `;
            return div;
        };
        northControl.addTo(map);
        
        console.log('Mapa inicializado. Tentando carregar Geomorf_Pindar√©.geojson automaticamente...');
        
        } // Fim da fun√ß√£o inicializarMapa
    </script>
</body>
</html>
